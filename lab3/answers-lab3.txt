Q1: What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)
A1: Different exceptions/interrupts have different to deal with. For example, the processor didn't pushed an error code onto the stack when some exceptions/interrupts occurred, so the interrupt handler should push an error code onto the stack manually(make sure the trap frame has the same format).If all exceptions/interrupts were delivered to the same handler, we can't figure out which exceptions/interrupts occured because the processor didn't save the vector number of current exceptino/interrupt.
Q2: Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?
A2: The DPL field of interrupt 13 (which is General Protection Exception) Descriptor was set to 0. This means the privilege level required for software to invoke this interrupt gate explicitly using an int instruction is 0. But user/softint program is running on user mode which privilege level is 3. So when user invoke int $14, it will violate the privilege rules, and the processor will produce a general protection.If the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler, it may intefere with our memory management and cause some problem that we didn't expect.
Q3: The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?
A3: The break point entry in the IDT has a field called DPL (descriptor privilege level). If we set the DPL of break point entry to 0, the break point test case will generate a general protection because the privilege level required for software invoke this interrupt gate is 0, but our program is running on user mode which DPL is 3. If we set the DPL of break point entry to 3, the break point test case will generate a break point exception since the privilege level required is equal to program's privilege level. In order to set up the break point entry correctly, we write our code like this: SETGATE(idt[3], 0, GD_KT, intr_handler_3, 3);
Q4: What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?
A4: The point of these mechanisms is to helps kernel's interrupt handler work correctly which means interrupt/trap handler will be executed only when the correspoding interrupt/trap occurred. These mechanisms also can avoid some malicious/buggy program abuse interrupt/trap.
